---
title: Table Dialect
description: Table Dialect describes how tabular data is stored in a file. It supports delimited text files like CSV, semi-structured formats like JSON and YAML, and spreadsheets like Microsoft Excel. The specification is designed to be expressible as a single JSON-compatible descriptor.
sidebar:
  order: 3
profile: /profiles/2.0/tabledialect.json
authors:
  - Rufus Pollock
  - Paul Walsh
  - Adam Kariv
  - Evgeny Karev
  - Peter Desmet
  - Kyle Husmann
  - Data Package Working Group
---

<table>
  <tr>
    <th>Authors</th>
    <td>{frontmatter.authors.join(", ")}</td>
  </tr>
  <tr>
    <th>Profile</th>
    <td>
      <a href={frontmatter.profile}>{frontmatter.profile}</a>
    </td>
  </tr>
</table>

<p>{frontmatter.description}</p>

## Language

The key words `MUST`, `MUST NOT`, `REQUIRED`, `SHALL`, `SHALL NOT`, `SHOULD`, `SHOULD NOT`, `RECOMMENDED`, `MAY`, and `OPTIONAL` in this document are to be interpreted as described in [RFC 2119](https://www.ietf.org/rfc/rfc2119.txt).

## Introduction

Table Dialect defines set of properties that can be used by data producers and data consumers to ensure data interoperability in various [Tabular Data](/standard/glossary/#tabular-data) formats such as CSV, JSON, or Excel. The main goal of this specification is to define a common language for defining tabular data dialects.

It is not expected that all the properties are supported by all the Data Package implementations. An implementation `MUST` choose the most suitable strategy for communicating to the users if some relevant feature is not supported.

Table Dialect is useful for programmes which might have to deal with multiple dialects of tabular files, but which can rely on being told out-of-band which dialect will be used in a given input stream. This reduces the need for heuristic inference of dialects, and simplifies the implementation of readers, which must juggle dialect inference, schema inference, unseekable input streams, character encoding issues, and the lazy reading of very large input streams.

:::note[Backward Compatibility]
Table Dialect supersedes [CSV Dialect](https://specs.frictionlessdata.io/csv-dialect/). Except for `caseSensitiveHeader` and `csvddfVersion` which are removed, all CSV Dialect properties are included in Table Dialect and can be used without changes.
:::

## Descriptor

Table Dialect descriptor `MUST` be a descriptor as per [Descriptor](/standard/glossary/#descriptor) definition. The descriptor `MAY` include a `type` property to indicate which of optional dialect properties `SHOULD` be considered when reading the target data format. Some [properties](#properties) are generic and can be used for multiple formats, while others are specific to one format. A list of standard dialect types are defined in the [Table Dialect Types](#table-dialect-types) section. The properties that can be used with these types are defined in the [Properties](#properties) section.

When the `type` property is not set, it `SHOULD` be assumed that the descriptor is a `delimited` dialect type. In this case, the [`$schema`](#schema) property `SHOULD` default to `https://datapackage.org/profiles/1.0/tabledialect.json`, to maintain backward compatibility with [CSV Dialect](https://specs.frictionlessdata.io/csv-dialect/).

An example of a Table Dialect descriptor:

```json
{
  "type": "delimited",
  "header": false,
  "delimiter": ";",
  "quoteChar": "'"
}
```

## Table Dialect Types

Table Dialect can be used for different data formats, such as delimited text files, semi-structured formats and spreadsheets. The list of supported dialect types with associated data formats and related properties is as follows.

### `delimited`

Delimited formats are textual formats such as CSV and TSV. Their charactistics can be expressed the following properties:

- [type](#type): `delimited`
- [$schema](#dollar-schema): `https://datapackage.org/profiles/2.0/tabledialect.json` by default
- [header](#header): `true` by default
- [headerRows](#headerRows): `1` by default
- [headerJoin](#headerJoin): ` ` by default
- [commentRows](#commentRows): undefined by default
- [commentChar](#commentChar): undefined by default
- [delimiter](#delimiter): `,` by default
- [lineTerminator](#lineTerminator): `\r\n` by default
- [quoteChar](#quoteChar): `"` by default
- [doubleQuote](#doubleQuote): `true` by default
- [escapeChar](#escapeChar): undefined by default
- [nullSequence](#nullSequence): undefined by default
- [skipInitialSpace](#skipInitialSpace): `false` by default

An example of a well-defined Table Dialect descriptor for a CSV format:

```json
{
  "type": "delimited",
  "header": false,
  "commentChar": "#"
  "delimiter": ";",
  "doubleQuote": true,
  "lineTerminator": "\r\n",
  "quoteChar": "\"",
  "skipInitialSpace": true,
}
```

### `structured`

Structured formats are structured or semi-structured formats such as JSON and YAML. Their charactistics can be expressed the following properties:

- [type](#type): `structured`
- [$schema](#dollar-schema): `https://datapackage.org/profiles/2.0/tabledialect.json` by default
- [header](#header): `true` by default
- [property](#property): undefined by default
- [itemType](#itemType): undefined by default
- [itemKeys](#itemKeys): undefined by default

### `spreadsheet`

Spreadsheet formats are sheet-based formats such as Excel or ODS. Their charactistics can be expressed the following properties:

- [type](#type): `spreadsheet`
- [$schema](#dollar-schema): `https://datapackage.org/profiles/2.0/tabledialect.json` by default
- [header](#header): `true` by default
- [headerRows](#headerRows): `1` by default
- [headerJoin](#headerJoin): ` ` by default
- [commentRows](#commentRows): undefined by default
- [commentChar](#commentChar): undefined by default
- [sheetNumber](#sheetNumber): `1` by default
- [sheetName](#sheetName): undefined by default

### `database`

Database formats is a group of formats accessing data from databases like SQLite. Their charactistics can be expressed the following properties:

- [type](#type): `database`
- [$schema](#dollar-schema): `https://datapackage.org/profiles/2.0/tabledialect.json` by default
- [table](#table): (required)

## Properties

### `type`

**Dialect Types:** All

A Table Dialect descriptor MAY contain a property `type` that `MUST` be a string with the following possible values and the `delimited` value by default: `delimited`, `structured`, `spreadsheet`, or `database`.

### `$schema` {#dollar-schema}

**Dialect Types:** All

A root level Table Dialect descriptor `MAY` have a `$schema` property that `MUST` be a profile as per [Profile](/standard/glossary/#profile) definition that `MUST` include all the metadata constraints required by this specification.

The default value is `https://datapackage.org/profiles/1.0/tabledialect.json` and the recommended value is `https://datapackage.org/profiles/2.0/tabledialect.json`.

### `header`

**Dialect Types:** [delimited](#delimited), [structured](#structured), [spreadsheet](#spreadsheet)

A Table Dialect descriptor `MAY` have the `header` property that `MUST` be boolean with default value `true`. This property indicates whether the file includes a header row. If `true` the first row in the file `MUST` be interpreted as a header row, not data.

For example, this data file:

```csv
1,apple
2,orange
```

With this dialect definition:

```json
{
  "type": "delimited",
  "header": false
}
```

`SHOULD` output this data:

```javascript
{field1: 1, field2: "apple"}
{field1: 2, field2: "orange"}
```

Where `field1` and `field2` names are implementation-specific and used here only for illustrative purpose.

### `headerRows` {#headerRows}

**Dialect Types:** [delimited](#delimited), [spreadsheet](#spreadsheet)

A Table Dialect descriptor `MAY` have the `headerRows` property that `MUST` be an array of positive integers starting from 1 with default value `[1]`. This property specifies the row numbers for the header. It is `RECOMMENDED` to be used for multiline-header files.

For example, this data file:

```csv
fruit
id,name
1,apple
2,orange
```

With this dialect definition:

```json
{
  "type": "delimited",
  "headerRows": [1, 2]
}
```

`SHOULD` output this data:

```javascript
{"fruit id": 1, "fruit name": "apple"}
{"fruit id": 2, "fruit name": "orange"}
```

### `headerJoin` {#headerJoin}

**Dialect Types:** [delimited](#delimited), [spreadsheet](#spreadsheet)

A Table Dialect descriptor `MAY` have the `headerJoin` property that `MUST` be a string with default value `" "`. This property specifies how multiline-header files have to join the resulting header rows.

For example, this data file:

```csv
fruit
id,name
1,apple
2,orange
```

With this dialect definition:

```json
{
  "type": "delimited",
  "headerRows": [1, 2],
  "headerJoin": "-"
}
```

`SHOULD` output this data:

```javascript
{"fruit-id": 1, "fruit-name": "apple"}
{"fruit-id": 2, "fruit-name": "orange"}
```

### `commentRows` {#commentRows}

**Dialect Types:** [delimited](#delimited), [spreadsheet](#spreadsheet)

A Table Dialect descriptor `MAY` have the `commentRows` property that `MUST` be an array of positive integers starting from 1; undefined by default. This property specifies what rows have to be omitted from the data.

For example, this data file:

```csv
id,name
#fruits
1,apple
2,orange
```

With this dialect definition:

```json
{
  "type": "delimited",
  "commentRows": [2]
}
```

`SHOULD` output this data:

```javascript
{id: 1, name: "apple"}
{id: 2, name: "orange"}
```

### `commentChar` {#commentChar}

**Dialect Types:** [delimited](#delimited), [spreadsheet](#spreadsheet)

A Table Dialect descriptor `MAY` have the `commentChar` property that `MUST` be a string of one or more characters; undefined by default. This property specifies what rows have to be omitted from the data based on the row's first characters.

For example, this data file:

```csv
id,name
#fruits
1,apple
2,orange
```

With this dialect definition:

```json
{
  "type": "delimited",
  "commentChar": "#"
}
```

`SHOULD` output this data:

```javascript
{id: 1, name: "apple"}
{id: 2, name: "orange"}
```

### `delimiter`

**Dialect Types:** [delimited](#delimited)

A Table Dialect descriptor `MAY` have the `delimiter` property that `MUST` be a string; with default value `,` (comma). This property specifies the character sequence which separates fields in the data file.

For example, this data file:

```csv
id|name
1|apple
2|orange
```

With this dialect definition:

```json
{
  "type": "delimited",
  "delimiter": "|"
}
```

`SHOULD` output this data:

```javascript
{id: 1, name: "apple"}
{id: 2, name: "orange"}
```

### `lineTerminator` {#lineTerminator}

**Dialect Types:** [delimited](#delimited)

A Table Dialect descriptor `MAY` have the `lineTerminator` property that `MUST` be a string; with default value `\r\n`. This property specifies the character sequence which terminates rows.

For example, this data file:

```csv
id,name;1,apple;2,orange
```

With this dialect definition:

```json
{
  "type": "delimited",
  "lineTerminator": ";"
}
```

`SHOULD` output this data:

```javascript
{id: 1, name: "apple"}
{id: 2, name: "orange"}
```

### `quoteChar` {#quoteChar}

**Dialect Types:** [delimited](#delimited)

A Table Dialect descriptor `MAY` have the `quoteChar` property that `MUST` be a string of one character length with default value `"` (double quote). This property specifies a character to use for quoting in case the `delimiter` needs to be used inside a data cell.

For example, this data file:

```csv
id,name
1,'apple,fruits'
2,'orange,fruits'
```

With this dialect definition:

```json
{
  "type": "delimited",
  "quoteChar": "'"
}
```

`SHOULD` output this data:

```javascript
{id: 1, name: "apple,fruits"}
{id: 2, name: "orange,fruits"}
```

### `doubleQuote` {#doubleQuote}

**Dialect Types:** [delimited](#delimited)

A Table Dialect descriptor `MAY` have the `doubleQuote` property that `MUST` be boolean with default value `true`. This property controls the handling of `quoteChar` inside data cells. If true, two consecutive quotes are interpreted as one.

For example, this data file:

```csv
id,name
1,"apple""fruits"
2,"orange""fruits"
```

With this dialect definition:

```json
{
  "type": "delimited",
  "doubleQuote": true
}
```

`SHOULD` output this data:

```javascript
{id: 1, name: 'apple"fruits'}
{id: 2, name: 'orange"fruits'}
```

### `escapeChar` {#escapeChar}

**Dialect Types:** [delimited](#delimited)

A Table Dialect descriptor `MAY` have the `escapeChar` property that `MUST` be a string of one character length; undefined by default. This property specifies a one-character string to use for escaping, for example, `\`, mutually exclusive with `quoteChar`.

For example, this data file:

```csv
id,name
1,apple|,fruits
2,orange|,fruits
```

With this dialect definition:

```json
{
  "type": "delimited",
  "escapeChar": "|"
}
```

`SHOULD` output this data:

```javascript
{id: 1, name: "apple,fruits"}
{id: 2, name: "orange,fruits"}
```

### `nullSequence` {#nullSequence}

**Dialect Types:** [delimited](#delimited)

A Table Dialect descriptor `MAY` have the `nullSequence` property that `MUST` be a string; undefined by default. This property specifies specifies the null sequence, for example, `\N`.

For example, this data file:

```csv
id,name
1,apple
2,NA
```

With this dialect definition:

```json
{
  "type": "delimited",
  "nullSequence": "NA"
}
```

`SHOULD` output this data:

```javascript
{id: 1, name: "apple"}
{id: 2, name: null}
```

### `skipInitialSpace` {#skipInitialSpace}

**Dialect Types:** [delimited](#delimited)

A Table Dialect descriptor `MAY` have the `skipInitialSpace` property that `MUST` be boolean with default value `false`. This property specifies how to interpret whitespace which immediately follows a delimiter; if `false`, it means that whitespace immediately after a delimiter is treated as part of the following field.

For example, this data file:

```csv
id, name
1, apple
2, orange
```

With this dialect definition:

```json
{
  "type": "delimited",
  "skipInitialSpace": true
}
```

`SHOULD` output this data:

```javascript
{id: 1, name: "apple"}
{id: 2, name: "orange"}
```

### `property`

**Dialect Types:** [structured](#structured)

A Table Dialect descriptor `MAY` have the `property` property that `MUST` be a string; undefined by default. This property specifies where a data array is located in the data structure.

For example, this data file:

```json
{
  "rows": [
    { "id": 1, "name": "apple" },
    { "id": 2, "name": "orange" }
  ]
}
```

With this dialect definition:

```json
{
  "type": "structured",
  "property": "rows"
}
```

`SHOULD` output this data:

```javascript
{id: 1, name: "apple"}
{id: 2, name: "orange"}
```

### `itemType` {#itemType}

**Dialect Types:** [structured](#structured)

A Table Dialect descriptor `MAY` have the `itemType` property that `MUST` be a string with value `array` or `object`; undefined by default. This property specifies whether the data `property` contains an array of arrays or an array of objects.

For example, this data file:

```json
[
  ["id", "name"],
  [1, "apple"],
  [2, "orange"]
]
```

With this dialect definition:

```json
{
  "type": "structured",
  "itemType": "array"
}
```

`SHOULD` output this data:

```javascript
{id: 1, name: "apple"}
{id: 2, name: "orange"}
```

### `itemKeys` {#itemKeys}

**Dialect Types:** [structured](#structured)

A Table Dialect descriptor `MAY` have the `itemKeys` property that `MUST` be array of strings; undefined by default. This property specifies the way of extracting rows from data arrays with `itemType` is `object`.

For example, this data file:

```json
[
  { "name": "apple", "id": 1, "count": 2 },
  { "id": 2, "name": "orange", "count": 5 }
]
```

With this dialect definition:

```json
{
  "type": "structured",
  "itemKeys": ["id", "name"]
}
```

`SHOULD` output this data:

```javascript
{id: 1, name: "apple"}
{id: 2, name: "orange"}
```

### `sheetNumber` {#sheetNumber}

**Dialect Types:** [spreadsheet](#spreadsheet)

A Table Dialect descriptor `MAY` have the `sheetNumber` property that `MUST` be an integer with default value `1`. This property specifies a sheet number of a table in the spreadsheet file.

For example, this data file:

```txt
Sheet 1
Sheet 2
```

With this dialect definition:

```json
{
  "type": "spreadsheet",
  "sheetNumber": 2
}
```

`SHOULD` output the data from the second sheet.

### `sheetName` {#sheetName}

**Dialect Types:** [spreadsheet](#spreadsheet)

A Table Dialect descriptor `MAY` have the `sheetName` property that `MUST` be a string; undefined by default. This property specifies a sheet name of a table in the spreadsheet file.

For example, this data file:

```txt
Sheet 1
Sheet 2
```

With this dialect definition:

```json
{
  "type": "spreadsheet",
  "sheetName": "Sheet 2"
}
```

`SHOULD` output the data from the second sheet.

### `table`

**Dialect Types:** [database](#database)

A Table Dialect of type `database` `MUST` have a `table` property of type string. This property specifies a name of the table in the database.

For example, the database with the tables below:

```txt
table1
table2
```

With this dialect definition:

```json
{
  "type": "database",
  "table": "table2"
}
```

`SHOULD` output the data from the second table.

## Excluded

Table Dialect has nothing to do with the names, contents or types of the headers or data within the CSV file (see [Table Schema](/standard/table-schema/) instead), only how it is formatted. However, Table Dialect does allow the presence or absence of a header to be specified, similarly to [RFC4180](http://www.ietf.org/rfc/rfc4180.txt).

Table Dialect is also orthogonal to the character encoding used in the CSV file. Note that it is possible for files in CSV format to contain data in more than one encoding.

## References

Some related work can be found in [similar JSON format](http://panda.readthedocs.org/en/latest/api.html#data-uploads) and in Python's [PEP 305](http://www.python.org/dev/peps/pep-0305/).
